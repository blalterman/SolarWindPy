#!/usr/bin/env python
"""Generate a Conda environment file from a pip-compile lockfile.

This script reads ``requirements.txt`` (generated by pip-compile from pyproject.toml)
and produces ``<env_name>.yml`` suitable for ``conda env create``.

**IMPORTANT**: This script reads LOCKFILES, not pyproject.toml directly.
Generate lockfile first via::

    pip-compile pyproject.toml --output-file=requirements.txt

The script automatically handles package name differences between pip and conda:
- PyTables: pip uses 'tables', conda uses 'pytables'
- This translation ensures lockfiles can use pip names while generating correct
  conda environment files

Examples
--------
Run with the default lockfile (requirements.txt)::

    pip-compile pyproject.toml --output-file=requirements.txt
    python scripts/requirements_to_conda_env.py
    conda env create -f solarwindpy.yml

Specify a different lockfile and environment name::

    python scripts/requirements_to_conda_env.py requirements-dev.lock --name solarwindpy-dev
    conda env create -f solarwindpy-dev.yml
"""

from __future__ import annotations

import argparse
import yaml

from pathlib import Path

# Package name translation map: pip_name -> conda_name
# This handles cases where pip and conda use different package names
PIP_TO_CONDA_NAMES = {
    "tables": "pytables",  # PyTables: pip uses 'tables', conda uses 'pytables'
    "blosc2": "python-blosc2",  # Blosc2: pip uses 'blosc2', conda uses 'python-blosc2'
    "msgpack": "msgpack-python",  # MessagePack: pip uses 'msgpack', conda uses 'msgpack-python'
    "mypy-extensions": "mypy_extensions",  # Underscore on conda-forge
    "restructuredtext-lint": "restructuredtext_lint",  # Underscore on conda-forge
}

# Packages that are pip-only (not available on conda-forge)
# These will be added to a `pip:` subsection in the conda yml
# Note: ast-grep is now provided via MCP server, not Python package
PIP_ONLY_PACKAGES: set[str] = set()  # Currently empty; add packages here as needed

# Packages with version schemes that differ between PyPI and conda-forge
# These packages have their versions stripped entirely to let conda resolve
# Reference: .claude/docs/root-cause-analysis/pr-405-conda-patching.md
INCOMPATIBLE_VERSION_SCHEMES = {
    "tzdata",  # PyPI: 2025.3 (dot notation), conda-forge: 2025a/b/c (letter suffix)
}

# If True, strip ALL version pins from exact matches (==) in the conda file.
# This is safe because:
# 1. Conda environment is used to set up the environment
# 2. pip install -e . uses pyproject.toml which has the real minimum requirements
# 3. The conda file just needs packages present, not pinned versions
STRIP_EXACT_VERSIONS = True


def translate_package_name(pip_name: str) -> str:
    """Translate pip package names to conda package names.

    Handles key differences between pip and conda:

    1. **Package names**: Some packages have different names
       (e.g., pip 'tables' â†’ conda 'pytables')

    2. **Version stripping**: By default (STRIP_EXACT_VERSIONS=True), exact
       version pins (==) are stripped entirely. This is safe because:
       - The conda environment just needs packages present
       - `pip install -e .` enforces pyproject.toml's minimum requirements
       - Avoids PyPI/conda-forge version mismatches

    3. **Incompatible version schemes**: Some packages (e.g., tzdata) use
       different version schemes on PyPI vs conda-forge and always have
       versions stripped.

    Parameters
    ----------
    pip_name : str
        Package name as used by pip (may include version specifiers)

    Returns
    -------
    str
        Package name translated for conda (typically without version)

    Notes
    -----
    The conda environment file is intentionally simple - just package names.
    Real version constraints come from pyproject.toml via `pip install -e .`
    after the conda environment is created.
    """
    # Handle version specifiers (e.g., "package>=1.0.0")
    for operator in [">=", "<=", "==", "!=", ">", "<", "~="]:
        if operator in pip_name:
            package, version = pip_name.split(operator, 1)
            package = package.strip()
            version = version.strip()
            translated_package = PIP_TO_CONDA_NAMES.get(package, package)

            # Packages with incompatible version schemes: strip version entirely
            if package in INCOMPATIBLE_VERSION_SCHEMES:
                return translated_package

            # For exact pins (==), either strip version or convert to minimum
            if operator == "==":
                if STRIP_EXACT_VERSIONS:
                    # Strip version entirely - let conda resolve
                    # pyproject.toml enforces minimum requirements via pip install -e .
                    return translated_package
                else:
                    # Fallback: convert to minimum version constraint
                    version_parts = version.split(".")
                    if len(version_parts) >= 2:
                        major_minor = ".".join(version_parts[:2])
                        return f"{translated_package}>={major_minor}"
                    else:
                        return f"{translated_package}>={version}"

            # Other operators: preserve as-is
            return f"{translated_package}{operator}{version}"

    # No version specifier, direct translation
    return PIP_TO_CONDA_NAMES.get(pip_name.strip(), pip_name.strip())


def generate_environment(req_path: str, env_name: str, overwrite: bool = False) -> None:
    """Create ``<env_name>.yml`` from a requirements file.

    Automatically translates pip package names to conda equivalents where needed.

    Parameters
    ----------
    req_path : str
        Path to the requirements file.
    env_name : str
        Name of the Conda environment.
    overwrite : bool
        Whether to overwrite existing environment files.
    """
    with open(req_path) as req_file:
        pip_packages = [
            line.strip()
            for line in req_file
            if line.strip() and not line.strip().startswith("#")
        ]

    # Helper to extract base package name (without version specifiers)
    def get_base_name(pkg: str) -> str:
        for op in [">=", "<=", "==", "!=", ">", "<", "~="]:
            if op in pkg:
                return pkg.split(op, 1)[0].strip()
        return pkg.strip()

    # Separate conda packages from pip-only packages
    conda_packages_raw = [
        pkg for pkg in pip_packages if get_base_name(pkg) not in PIP_ONLY_PACKAGES
    ]
    pip_only_raw = [
        pkg for pkg in pip_packages if get_base_name(pkg) in PIP_ONLY_PACKAGES
    ]

    # Translate conda package names (pip names -> conda names)
    conda_packages = [translate_package_name(pkg) for pkg in conda_packages_raw]

    # Strip versions from pip-only packages (let pip resolve)
    pip_only_packages = [get_base_name(pkg) for pkg in pip_only_raw]

    if pip_only_packages:
        print(f"Note: Adding pip-only packages to pip: subsection: {pip_only_packages}")

    # Build dependencies list
    dependencies = conda_packages.copy()

    # Add pip subsection if there are pip-only packages
    if pip_only_packages:
        dependencies.append("pip")
        dependencies.append({"pip": pip_only_packages})

    env = {
        "name": env_name,
        "channels": ["conda-forge"],
        "dependencies": dependencies,
    }

    target_name = Path(f"{env_name}.yml")

    if target_name.exists() and not overwrite:
        print(f"Error: {target_name} already exists. Use --overwrite to replace it.")
        raise FileExistsError(f"{target_name} already exists")

    # Write environment file with explanatory header
    header = """\
# SolarWindPy Conda Environment File
#
# This file lists packages WITHOUT version pins. This is intentional:
# 1. Conda resolves to latest compatible versions from conda-forge
# 2. `pip install -e .` enforces pyproject.toml's minimum requirements
# 3. Avoids PyPI/conda-forge version mismatches that break CI
#
# Technical details: .claude/docs/root-cause-analysis/pr-405-conda-patching.md
#
# NOTE: Python version is dynamically injected by GitHub Actions workflows
# during matrix testing to support multiple Python versions.
#
# NOTE: Pip-only packages (e.g., ast-grep-py) are included in the pip: subsection
# at the end of dependencies and installed automatically during env creation.
#
# For local use:
#   conda env create -f solarwindpy.yml
#   conda activate solarwindpy
#   pip install -e .  # Installs SolarWindPy in editable mode
#
"""
    with open(target_name, "w") as out_file:
        out_file.write(header)
        yaml.safe_dump(env, out_file, sort_keys=False)


def main() -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "requirements",
        nargs="?",
        default="requirements.txt",
        help="Path to the pip-compile lockfile (e.g., requirements.txt, requirements-dev.lock).",
    )
    parser.add_argument(
        "--name",
        default="solarwindpy",
        help="Name of the Conda environment.",
    )
    parser.add_argument(
        "--overwrite",
        action="store_true",
        help="Overwrite existing environment files.",
    )
    args = parser.parse_args()

    generate_environment(args.requirements, args.name, args.overwrite)


if __name__ == "__main__":
    main()
