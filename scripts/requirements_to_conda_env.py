#!/usr/bin/env python
"""Generate a Conda environment file from a pip-compile lockfile.

This script reads ``requirements.txt`` (generated by pip-compile from pyproject.toml)
and produces ``<env_name>.yml`` suitable for ``conda env create``.

**IMPORTANT**: This script reads LOCKFILES, not pyproject.toml directly.
Generate lockfile first via::

    pip-compile pyproject.toml --output-file=requirements.txt

The script automatically handles package name differences between pip and conda:
- PyTables: pip uses 'tables', conda uses 'pytables'
- This translation ensures lockfiles can use pip names while generating correct
  conda environment files

Examples
--------
Run with the default lockfile (requirements.txt)::

    pip-compile pyproject.toml --output-file=requirements.txt
    python scripts/requirements_to_conda_env.py
    conda env create -f solarwindpy.yml

Specify a different lockfile and environment name::

    python scripts/requirements_to_conda_env.py requirements-dev.lock --name solarwindpy-dev
    conda env create -f solarwindpy-dev.yml
"""

from __future__ import annotations

import argparse
import yaml

from pathlib import Path

# Package name translation map: pip_name -> conda_name
# This handles cases where pip and conda use different package names
PIP_TO_CONDA_NAMES = {
    "tables": "pytables",  # PyTables: pip uses 'tables', conda uses 'pytables'
}

# Packages with version schemes that differ between PyPI and conda-forge
# These packages have their versions stripped entirely to let conda resolve
# Reference: .claude/docs/root-cause-analysis/pr-405-conda-patching.md
INCOMPATIBLE_VERSION_SCHEMES = {
    "tzdata",  # PyPI: 2025.3 (dot notation), conda-forge: 2025a/b/c (letter suffix)
}


def translate_package_name(pip_name: str) -> str:
    """Translate pip package names to conda package names.

    Handles three key differences between pip and conda:

    1. **Package names**: Some packages have different names
       (e.g., pip 'tables' → conda 'pytables')

    2. **Version syntax**: pip uses '==' for exact, conda uses '='

    3. **Version availability**: PyPI versions may not exist on conda-forge.
       For exact pins (==), this function converts to minimum version (>=)
       using only major.minor, allowing conda to resolve to available versions.

    4. **Version scheme differences**: Some packages use incompatible version
       schemes between PyPI and conda-forge (e.g., tzdata: 2025.3 vs 2025a).
       These have versions stripped entirely.

    Parameters
    ----------
    pip_name : str
        Package name as used by pip (may include version specifiers)

    Returns
    -------
    str
        Package name translated for conda, with version syntax converted

    Notes
    -----
    This approach ensures conda environment files work with conda-forge even
    when PyPI pins versions that don't exist on conda-forge. The trade-off
    is reduced reproducibility in exchange for CI stability.

    For reproducible installs, use pip with requirements.txt directly.
    """
    # Handle version specifiers (e.g., "package>=1.0.0")
    for operator in [">=", "<=", "==", "!=", ">", "<", "~="]:
        if operator in pip_name:
            package, version = pip_name.split(operator, 1)
            package = package.strip()
            version = version.strip()
            translated_package = PIP_TO_CONDA_NAMES.get(package, package)

            # Packages with incompatible version schemes: strip version entirely
            if package in INCOMPATIBLE_VERSION_SCHEMES:
                return translated_package

            # For exact pins (==), convert to minimum version constraint
            # This allows conda-forge to resolve to available versions
            # Example: numexpr==2.11.0 → numexpr>=2.11
            if operator == "==":
                version_parts = version.split(".")
                if len(version_parts) >= 2:
                    major_minor = ".".join(version_parts[:2])
                    return f"{translated_package}>={major_minor}"
                else:
                    # Single-part version, use as minimum
                    return f"{translated_package}>={version}"

            # Other operators: preserve as-is
            return f"{translated_package}{operator}{version}"

    # No version specifier, direct translation
    return PIP_TO_CONDA_NAMES.get(pip_name.strip(), pip_name.strip())


def generate_environment(req_path: str, env_name: str, overwrite: bool = False) -> None:
    """Create ``<env_name>.yml`` from a requirements file.

    Automatically translates pip package names to conda equivalents where needed.

    Parameters
    ----------
    req_path : str
        Path to the requirements file.
    env_name : str
        Name of the Conda environment.
    overwrite : bool
        Whether to overwrite existing environment files.
    """
    with open(req_path) as req_file:
        pip_packages = [
            line.strip()
            for line in req_file
            if line.strip() and not line.strip().startswith("#")
        ]

    # Translate pip package names to conda equivalents
    conda_packages = [translate_package_name(pkg) for pkg in pip_packages]

    env = {
        "name": env_name,
        "channels": ["conda-forge"],
        "dependencies": conda_packages,
    }

    target_name = Path(f"{env_name}.yml")

    if target_name.exists() and not overwrite:
        print(f"Error: {target_name} already exists. Use --overwrite to replace it.")
        raise FileExistsError(f"{target_name} already exists")

    # Write environment file with explanatory header
    header = """\
# SolarWindPy Conda Environment File
#
# NOTE: Python version is intentionally NOT specified in this file.
# It is dynamically injected by GitHub Actions workflows during matrix testing
# to avoid setup-miniconda@v3 patching issues that break dependency resolution.
# Technical details: .claude/docs/root-cause-analysis/pr-405-conda-patching.md
#
# IMPORTANT: Version constraints use >= instead of exact pins (=).
# This allows conda-forge to resolve to available versions, since PyPI and
# conda-forge may have different versions available. For reproducible installs,
# use pip with requirements.txt directly.
#
# For local use:
#   conda env create -f solarwindpy.yml
#   (conda will resolve to latest compatible versions)
#
"""
    with open(target_name, "w") as out_file:
        out_file.write(header)
        yaml.safe_dump(env, out_file, sort_keys=False)


def main() -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "requirements",
        nargs="?",
        default="requirements.txt",
        help="Path to the pip-compile lockfile (e.g., requirements.txt, requirements-dev.lock).",
    )
    parser.add_argument(
        "--name",
        default="solarwindpy",
        help="Name of the Conda environment.",
    )
    parser.add_argument(
        "--overwrite",
        action="store_true",
        help="Overwrite existing environment files.",
    )
    args = parser.parse_args()

    generate_environment(args.requirements, args.name, args.overwrite)


if __name__ == "__main__":
    main()
